/**
 * Revised sketch (single PDE)
 *
 * - size() in setup()
 * - 2D-only (no P3D)
 * - Uniform cone geometry generated by 3D math (rotate -> orthographic project)
 * - Subdivide each quadratic curve into multiple quadratic sub-curves (each drawn separately)
 * - Smooth color fade by distance (on-screen and in exported SVG)
 * - Edge noise applied only to rim radius (default 0 => perfect ellipse)
 * - UI in top-left, drawn on top, with black variable-name labels (interactive)
 * - Stroke weight fixed to 1
 *
 * Requirements:
 *  - ControlP5
 *  - processing.svg
 */

import controlP5.*;
import processing.svg.*;

ControlP5 cp5;

// UI-controlled parameters (sensible defaults)
float rotateX = 1.0;      // simulated tilt about X (radians)
float rotateY = 0.0;      // simulated tilt about Y (radians)
float rotateZ = 0.0;      // in-plane rotation (radians)
float depth   = 220.0;    // cone height (z of rim circle)
float rimRadius = 220.0;  // base radius of the cone (circle before rotation)
float amplitude = 60.0;   // offset for arc control point (positive -> outward)
float curveWeight = 0.5;  // 0..1 where the bend sits along the radial
int petalCount = 180;
int segmentCount = 4;     // subdivisions per petal (1 = continuous)
float edgeNoise = 0.0;    // noise amount applied to rim radius (0 => perfect ellipse)
float noiseScale = 0.08;
boolean exporting = false;
float irregularity = 0;
float petalBumps = 5;

void setup() {
  // size placed in setup to avoid the settings() issue you flagged
  size(1000, 1000, P2D);
  smooth(8);
  noiseSeed(25);
  noiseDetail(1);

  cp5 = new ControlP5(this);

  // top-left UI layout (coordinates used later to draw labels exactly)
  int sx = 12;
  int sy = 12;
  int sw = 220;
  int sh = 16;
  int spacing = 28;

  // NOTE: we do not rely on the slider's built-in label; we draw our own black labels
  cp5.addSlider("rotateX")
     .setPosition(sx, sy + spacing * 0).setSize(sw, sh)
     .setRange(-PI/2, PI/2).setValue(rotateX).setLabel("");

  cp5.addSlider("rotateY")
     .setPosition(sx, sy + spacing * 1).setSize(sw, sh)
     .setRange(-PI/2, PI/2).setValue(rotateY).setLabel("");

  cp5.addSlider("rotateZ")
     .setPosition(sx, sy + spacing * 2).setSize(sw, sh)
     .setRange(-PI, PI).setValue(rotateZ).setLabel("");

  cp5.addSlider("rimRadius")
     .setPosition(sx, sy + spacing * 3).setSize(sw, sh)
     .setRange(10, 700).setValue(rimRadius).setLabel("");

  cp5.addSlider("depth")
     .setPosition(sx, sy + spacing * 4).setSize(sw, sh)
     .setRange(0, 500).setValue(depth).setLabel("");

  cp5.addSlider("amplitude")
     .setPosition(sx, sy + spacing * 5).setSize(sw, sh)
     .setRange(-400, 400).setValue(amplitude).setLabel("");

  cp5.addSlider("curveWeight")
     .setPosition(sx, sy + spacing * 6).setSize(sw, sh)
     .setRange(0.0, 1.0).setValue(curveWeight).setLabel("");

  cp5.addSlider("petalCount")
     .setPosition(sx, sy + spacing * 7).setSize(sw, sh)
     .setRange(3, 500).setNumberOfTickMarks(998).setValue(petalCount).setLabel("");

  cp5.addSlider("segmentCount")
     .setPosition(sx, sy + spacing * 8).setSize(sw, sh)
     .setRange(1, 10).setValue(segmentCount).setLabel("");

  cp5.addSlider("edgeNoise")
     .setPosition(sx, sy + spacing * 9).setSize(sw, sh)
     .setRange(0.0, 200.0).setValue(edgeNoise).setLabel("");
     
  cp5.addSlider("noiseScale")
     .setPosition(sx, sy + spacing * 10).setSize(sw, sh)
     .setRange(0.0, 10).setValue(noiseScale).setLabel("");

  cp5.addSlider("irregularity")
     .setPosition(sx, sy + spacing * 11).setSize(sw, sh)
     .setRange(0.0, 1.0).setValue(irregularity).setLabel("");
  cp5.addSlider("petalBumps")
     .setPosition(sx, sy + spacing * 12).setSize(sw, sh)
     .setRange(0.0, 12.0).setValue(petalBumps).setLabel("");

  cp5.addButton("exportSVG")
     .setPosition(sx, sy + spacing * 13 + 4).setSize(120, 20).setLabel("Export SVG");
}

void draw() {
  // read UI each frame (keeps values in sync)
  rotateX = cp5.getController("rotateX").getValue();
  rotateY = cp5.getController("rotateY").getValue();
  rotateZ = cp5.getController("rotateZ").getValue();
  rimRadius = cp5.getController("rimRadius").getValue();
  depth = cp5.getController("depth").getValue();
  amplitude = cp5.getController("amplitude").getValue();
  curveWeight = cp5.getController("curveWeight").getValue();
  petalCount = max(3, round(cp5.getController("petalCount").getValue()));
  segmentCount = max(1, round(cp5.getController("segmentCount").getValue()));
  edgeNoise = cp5.getController("edgeNoise").getValue();
  noiseScale = cp5.getController("noiseScale").getValue();
  irregularity = cp5.getController("irregularity").getValue();
  petalBumps = round(cp5.getController("petalBumps").getValue());


  // Export path: when exporting is true we record only the flower (no UI) into an SVG file.
  if (exporting) {
    // timestamped filename so repeated exports don't overwrite unexpectedly
    String fname = "flower_output.svg";
    beginRecord(SVG, fname);
    background(255);
    drawFlower();   // draw the flower into the SVG
    endRecord();
    exporting = false;
    println("Export complete: " + fname);
    // continue to also draw on-screen (below) so the UI remains visible after export
  }

  // On-screen draw
  background(255);
  drawFlower();

  // ensure UI sits on top and is interactive: draw CP5 after resetting matrix
  resetMatrix();
  hint(DISABLE_DEPTH_TEST); // avoid accidental occlusion
  cp5.draw();
  drawLabelsTopLeft();      // black variable-name labels next to sliders
  hint(ENABLE_DEPTH_TEST);
}

/* Draw the flower (shared by on-screen and SVG export) */
void drawFlower() {
  // center origin for the flower
  pushMatrix();
  translate(width * 0.5, height * 0.75 - 10);

  // We'll compute colors explicitly via HSB->RGB conversion so the SVG receives the same RGB values
  strokeWeight(1.5); // fixed
  noFill();

  // cone apex in model space
  PVector apex = new PVector(0, 0, 0);
  PVector axis = new PVector(0, 0, 1); // cone axis in model space

  // Use static noise seed so the edge perturbation is stable
  float noiseOffset = 0.0; // static; you could expose as slider if you want variation

  for (int i = 0; i < petalCount; i++) {
    float theta = TWO_PI * i / (float)petalCount;
      
      theta += irregularity * noise(i);

    // rim radius plus optional edge noise (default 0 -> perfect ellipse)
    float localR = depth;
    float localRimRadius = rimRadius;
    if (edgeNoise > 0.0001) {
      float n = noise(sin(theta) * noiseScale + 37.123); // fixed offset produces stable wave
      localR += map(n, 0, 1, 0, edgeNoise);
      localRimRadius += map(n, 0, 1, 0, edgeNoise);
      
      
      localRimRadius += edgeNoise * abs(sin(theta * petalBumps));
    }
    

    // rim point in model space (circle at z = depth)
    
    PVector rimModel = new PVector(localRimRadius * cos(theta), localRimRadius * sin(theta), depth + localR);

    // mid point along radial (in model space)
    PVector midModel = PVector.lerp(apex, rimModel, curveWeight);

    // compute radial vector (apex->rim) in model space
    PVector radial = PVector.sub(rimModel, apex); // equals rimModel
    if (radial.mag() == 0) radial.set(1, 0, 0);

    // compute plane-normal that lies in the plane (axis, radial) and is perpendicular to radial
    // method: temp = axis x radial ; normal = temp x radial
    PVector temp = new PVector();
    PVector normalModel = new PVector();
    PVector.cross(axis, radial, temp);        // temp = axis x radial
    PVector.cross(temp, radial, normalModel); // normalModel = temp x radial
    normalModel.normalize();

    // control point base in model space
    PVector ctrlModel = PVector.add(midModel, PVector.mult(normalModel, amplitude));

    // rotate model-space points into world-space (apply rotX, rotY, rotZ)
    PVector rimWorld  = rotatePoint3D(rimModel,  rotateX, rotateY, rotateZ);
    PVector ctrlWorld = rotatePoint3D(ctrlModel, rotateX, rotateY, rotateZ);
    PVector apexWorld = rotatePoint3D(apex,      rotateX, rotateY, rotateZ); // still origin but keep for completeness

    // project orthographically to 2D (drop z)
    PVector a2 = new PVector(apexWorld.x, apexWorld.y);
    PVector c2 = new PVector(ctrlWorld.x, ctrlWorld.y);
    PVector r2 = new PVector(rimWorld.x, rimWorld.y);

    // subdivide the quadratic (a2 -> c2 -> r2) into segmentCount quadratic sub-curves,
    // deriving each sub-quad's control point so each sub-piece exactly follows the original curve on that subrange.
    for (int s = 0; s < segmentCount; s++) {
      float t0 = (float)s / segmentCount;
      float t1 = (float)(s + 1) / segmentCount;
      float tm = (t0 + t1) * 0.5;

      // sample three points on the original quadratic
      PVector P0 = quadPoint2D(a2, c2, r2, t0);
      PVector Pm = quadPoint2D(a2, c2, r2, tm);
      PVector P2 = quadPoint2D(a2, c2, r2, t1);

      // reconstruct the quadratic control point Cp so that quad(P0, Cp, P2) passes through Pm at t=0.5:
      // 0.25*P0 + 0.5*Cp + 0.25*P2 = Pm  => Cp = 2*Pm - 0.5*(P0 + P2)
      PVector Cp = PVector.sub(PVector.mult(Pm, 2.0), PVector.mult(PVector.add(P0, P2), 0.5));

      // convert quadratic (P0, Cp, P2) into cubic control points for bezier():
      // cubicC1 = P0 + 2/3*(Cp - P0)
      // cubicC2 = P2 + 2/3*(Cp - P2)
      PVector cubicC1 = PVector.add(P0, PVector.mult(PVector.sub(Cp, P0), 2.0/3.0));
      PVector cubicC2 = PVector.add(P2, PVector.mult(PVector.sub(Cp, P2), 2.0/3.0));

      // color: pick a hue based on midpoint distance from center (smooth fade)
      float distMid = Pm.mag(); // distance in screen pixels
      float hue = (s * 40) % 128;
      //float hue = map(distMid, 0, max(1, rimRadius), 220, 30); // cool -> warm
      int rgb = hsbToRgbInt(hue, 0, hue);
      stroke(rgb);

      // draw the sub-Bézier as its own disconnected geometry piece
      bezier(P0.x, P0.y, cubicC1.x, cubicC1.y, cubicC2.x, cubicC2.y, P2.x, P2.y);
    }
  }

  popMatrix();
}

/* rotate a 3D point by ax (X), ay (Y), az (Z) — returns a new PVector */
PVector rotatePoint3D(PVector p, float ax, float ay, float az) {
  float x = p.x;
  float y = p.y;
  float z = p.z;

  // rotate X
  float cosx = cos(ax), sinx = sin(ax);
  float y1 = y * cosx - z * sinx;
  float z1 = y * sinx + z * cosx;
  y = y1; z = z1;

  // rotate Y
  float cosy = cos(ay), siny = sin(ay);
  float x1 = x * cosy + z * siny;
  float z2 = -x * siny + z * cosy;
  x = x1; z = z2;

  // rotate Z
  float cosz = cos(az), sinz = sin(az);
  float x2 = x * cosz - y * sinz;
  float y2 = x * sinz + y * cosz;
  x = x2; y = y2;

  return new PVector(x, y, z);
}

/* Quadratic Bezier point in 2D */
PVector quadPoint2D(PVector A, PVector B, PVector C, float t) {
  float u = 1.0 - t;
  float x = u*u*A.x + 2*u*t*B.x + t*t*C.x;
  float y = u*u*A.y + 2*u*t*B.y + t*t*C.y;
  return new PVector(x, y);
}

/* Draw black labels next to the sliders (screen space) */
void drawLabelsTopLeft() {
  fill(0);
  textSize(12);
  textAlign(LEFT, CENTER);

  int sx = 12;
  int sw = 220;
  int spacing = 28;
  int labelX = sx + sw + 8;

  text("rotateX",    labelX, labelY(spacing, 0));
  text("rotateY",    labelX, labelY(spacing, 1));
  text("rotateZ",    labelX, labelY(spacing, 2));
  text("rimRadius",  labelX, labelY(spacing, 3));
  text("depth",      labelX, labelY(spacing, 4));
  text("amplitude",  labelX, labelY(spacing, 5));
  text("curveWeight",labelX, labelY(spacing, 6));
  text("petalCount", labelX, labelY(spacing, 7));
  text("segmentCount", labelX, labelY(spacing, 8));
  text("edgeNoise",  labelX, labelY(spacing, 9));
  text("noiseScale",  labelX, labelY(spacing, 10));
  text("irregularity",  labelX, labelY(spacing, 11));
  text("petalBumps",  labelX, labelY(spacing, 12));
}

int labelY(int spacing, int idx) {
  int base = 12;
  return base + spacing * idx + 9;
}

/* ControlP5 callback for export button */
void exportSVG() {
  exporting = true;
}

/* HSB -> RGB color conversion returning a Processing int color */
int hsbToRgbInt(float h, float s, float v) {
  float H = ((h % 360) + 360) % 360 / 360.0;
  float S = constrain(s / 100.0, 0, 1);
  float V = constrain(v / 100.0, 0, 1);

  float r=0, g=0, b=0;
  if (S == 0) {
    r = g = b = V;
  } else {
    float h6 = H * 6.0;
    int i = floor(h6);
    float f = h6 - i;
    float p = V * (1 - S);
    float q = V * (1 - S * f);
    float t = V * (1 - S * (1 - f));
    switch (i) {
      case 0: r = V; g = t; b = p; break;
      case 1: r = q; g = V; b = p; break;
      case 2: r = p; g = V; b = t; break;
      case 3: r = p; g = q; b = V; break;
      case 4: r = t; g = p; b = V; break;
      default: r = V; g = p; b = q; break;
    }
  }
  return color(round(r * 255), round(g * 255), round(b * 255));
}
